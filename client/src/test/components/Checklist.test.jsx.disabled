import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import Checklist from '../../components/Checklist.jsx';

describe('Checklist Component', () => {
  let mockOnChange;
  let user;
  let defaultProps;

  beforeEach(() => {
    mockOnChange = vi.fn();
    user = userEvent.setup();
    defaultProps = {
      checklist: [
        { étape: 'Étape 1' },
        { étape: 'Étape 2' },
        { étape: 'Étape 3' }
      ],
      role: 'Développeur Junior',
      department: 'Informatique',
      onChange: mockOnChange,
      readOnly: false
    };
  });

  describe('Rendering', () => {
    it('renders checklist title and metadata', () => {
      render(<Checklist {...defaultProps} />);
      
      expect(screen.getByText("Checklist d'Intégration")).toBeInTheDocument();
      expect(screen.getByText('Développeur Junior')).toBeInTheDocument();
      expect(screen.getByText('Informatique')).toBeInTheDocument();
    });

    it('renders all checklist items', () => {
      render(<Checklist {...defaultProps} />);
      
      expect(screen.getByText('Étape 1')).toBeInTheDocument();
      expect(screen.getByText('Étape 2')).toBeInTheDocument();
      expect(screen.getByText('Étape 3')).toBeInTheDocument();
    });

    it('renders checklist items with CheckCircle icons', () => {
      render(<Checklist {...defaultProps} />);
      
      const checkIcons = screen.getAllByTestId('CheckCircleIcon');
      expect(checkIcons).toHaveLength(4); // 3 items + 1 add icon
    });

    it('renders add item option when not readonly', () => {
      render(<Checklist {...defaultProps} />);
      
      expect(screen.getByText('Ajouter un élément')).toBeInTheDocument();
    });

    it('does not render add item option when readonly', () => {
      render(<Checklist {...defaultProps} readOnly={true} />);
      
      expect(screen.queryByText('Ajouter un élément')).not.toBeInTheDocument();
    });
  });

  describe('String Format Support', () => {
    it('handles string format checklist items', () => {
      const stringChecklist = ['Étape 1', 'Étape 2', 'Étape 3'];
      render(<Checklist {...defaultProps} checklist={stringChecklist} />);
      
      expect(screen.getByText('Étape 1')).toBeInTheDocument();
      expect(screen.getByText('Étape 2')).toBeInTheDocument();
      expect(screen.getByText('Étape 3')).toBeInTheDocument();
    });
  });

  describe('Edit Functionality', () => {
    it('shows edit and delete buttons when not readonly', () => {
      render(<Checklist {...defaultProps} />);
      
      const editButtons = screen.getAllByTestId('EditIcon');
      const deleteButtons = screen.getAllByTestId('DeleteIcon');
      
      expect(editButtons).toHaveLength(3);
      expect(deleteButtons).toHaveLength(3);
    });

    it('does not show edit and delete buttons when readonly', () => {
      render(<Checklist {...defaultProps} readOnly={true} />);
      
      expect(screen.queryByTestId('EditIcon')).not.toBeInTheDocument();
      expect(screen.queryByTestId('DeleteIcon')).not.toBeInTheDocument();
    });

    it('enters edit mode when edit button is clicked', async () => {
      render(<Checklist {...defaultProps} />);
      
      const editButtons = screen.getAllByTestId('EditIcon');
      await user.click(editButtons[0].closest('button'));
      
      expect(screen.getByDisplayValue('Étape 1')).toBeInTheDocument();
      expect(screen.getByTestId('SaveIcon')).toBeInTheDocument();
      expect(screen.getByTestId('CancelIcon')).toBeInTheDocument();
    });

    it('saves edited item when save button is clicked', async () => {
      render(<Checklist {...defaultProps} />);
      
      const editButtons = screen.getAllByLabelText(/edit/i);
      await user.click(editButtons[0]);
      
      const input = screen.getByDisplayValue('Étape 1');
      await user.clear(input);
      await user.type(input, 'Étape modifiée');
      
      const saveButton = screen.getByLabelText(/save/i);
      await user.click(saveButton);
      
      expect(mockOnChange).toHaveBeenCalledWith([
        { étape: 'Étape modifiée' },
        { étape: 'Étape 2' },
        { étape: 'Étape 3' }
      ]);
    });

    it('saves on Enter key press', async () => {
      render(<Checklist {...defaultProps} />);
      
      const editButtons = screen.getAllByLabelText(/edit/i);
      await user.click(editButtons[0]);
      
      const input = screen.getByDisplayValue('Étape 1');
      await user.clear(input);
      await user.type(input, 'Étape modifiée{enter}');
      
      expect(mockOnChange).toHaveBeenCalledWith([
        { étape: 'Étape modifiée' },
        { étape: 'Étape 2' },
        { étape: 'Étape 3' }
      ]);
    });

    it('cancels edit when cancel button is clicked', async () => {
      render(<Checklist {...defaultProps} />);
      
      const editButtons = screen.getAllByLabelText(/edit/i);
      await user.click(editButtons[0]);
      
      const input = screen.getByDisplayValue('Étape 1');
      await user.clear(input);
      await user.type(input, 'Étape modifiée');
      
      const cancelButton = screen.getByLabelText(/cancel/i);
      await user.click(cancelButton);
      
      expect(screen.getByText('Étape 1')).toBeInTheDocument();
      expect(mockOnChange).not.toHaveBeenCalled();
    });

    it('does not save empty text', async () => {
      render(<Checklist {...defaultProps} />);
      
      const editButtons = screen.getAllByLabelText(/edit/i);
      await user.click(editButtons[0]);
      
      const input = screen.getByDisplayValue('Étape 1');
      await user.clear(input);
      
      const saveButton = screen.getByLabelText(/save/i);
      await user.click(saveButton);
      
      expect(mockOnChange).not.toHaveBeenCalled();
    });
  });

  describe('Delete Functionality', () => {
    it('deletes item when delete button is clicked', async () => {
      render(<Checklist {...defaultProps} />);
      
      const deleteButtons = screen.getAllByLabelText(/delete/i);
      await user.click(deleteButtons[1]); // Delete second item
      
      expect(mockOnChange).toHaveBeenCalledWith([
        { étape: 'Étape 1' },
        { étape: 'Étape 3' }
      ]);
    });
  });

  describe('Add New Item Functionality', () => {
    it('shows add form when "Ajouter un élément" is clicked', async () => {
      render(<Checklist {...defaultProps} />);
      
      const addLink = screen.getByText('Ajouter un élément');
      await user.click(addLink);
      
      expect(screen.getByPlaceholderText('Nouveau élément...')).toBeInTheDocument();
      expect(screen.getByLabelText(/save/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/cancel/i)).toBeInTheDocument();
    });

    it('adds new item when save button is clicked', async () => {
      render(<Checklist {...defaultProps} />);
      
      const addLink = screen.getByText('Ajouter un élément');
      await user.click(addLink);
      
      const input = screen.getByPlaceholderText('Nouveau élément...');
      await user.type(input, 'Nouvelle étape');
      
      const saveButton = screen.getByLabelText(/save/i);
      await user.click(saveButton);
      
      expect(mockOnChange).toHaveBeenCalledWith([
        { étape: 'Étape 1' },
        { étape: 'Étape 2' },
        { étape: 'Étape 3' },
        { étape: 'Nouvelle étape' }
      ]);
    });

    it('adds new item on Enter key press', async () => {
      render(<Checklist {...defaultProps} />);
      
      const addLink = screen.getByText('Ajouter un élément');
      await user.click(addLink);
      
      const input = screen.getByPlaceholderText('Nouveau élément...');
      await user.type(input, 'Nouvelle étape{enter}');
      
      expect(mockOnChange).toHaveBeenCalledWith([
        { étape: 'Étape 1' },
        { étape: 'Étape 2' },
        { étape: 'Étape 3' },
        { étape: 'Nouvelle étape' }
      ]);
    });

    it('cancels add when cancel button is clicked', async () => {
      render(<Checklist {...defaultProps} />);
      
      const addLink = screen.getByText('Ajouter un élément');
      await user.click(addLink);
      
      const input = screen.getByPlaceholderText('Nouveau élément...');
      await user.type(input, 'Nouvelle étape');
      
      const cancelButton = screen.getByLabelText(/cancel/i);
      await user.click(cancelButton);
      
      expect(screen.getByText('Ajouter un élément')).toBeInTheDocument();
      expect(mockOnChange).not.toHaveBeenCalled();
    });

    it('does not add empty item', async () => {
      render(<Checklist {...defaultProps} />);
      
      const addLink = screen.getByText('Ajouter un élément');
      await user.click(addLink);
      
      const saveButton = screen.getByLabelText(/save/i);
      await user.click(saveButton);
      
      expect(mockOnChange).not.toHaveBeenCalled();
    });

    it('handles string format when adding to string checklist', async () => {
      const stringChecklist = ['Étape 1', 'Étape 2'];
      render(<Checklist {...defaultProps} checklist={stringChecklist} />);
      
      const addLink = screen.getByText('Ajouter un élément');
      await user.click(addLink);
      
      const input = screen.getByPlaceholderText('Nouveau élément...');
      await user.type(input, 'Nouvelle étape');
      
      const saveButton = screen.getByLabelText(/save/i);
      await user.click(saveButton);
      
      expect(mockOnChange).toHaveBeenCalledWith([
        'Étape 1',
        'Étape 2',
        'Nouvelle étape'
      ]);
    });
  });

  describe('Keyboard Navigation', () => {
    it('focuses input when entering edit mode', async () => {
      render(<Checklist {...defaultProps} />);
      
      const editButtons = screen.getAllByLabelText(/edit/i);
      await user.click(editButtons[0]);
      
      const input = screen.getByDisplayValue('Étape 1');
      expect(input).toHaveFocus();
    });

    it('focuses input when entering add mode', async () => {
      render(<Checklist {...defaultProps} />);
      
      const addLink = screen.getByText('Ajouter un élément');
      await user.click(addLink);
      
      const input = screen.getByPlaceholderText('Nouveau élément...');
      expect(input).toHaveFocus();
    });
  });

  describe('Edge Cases', () => {
    it('handles empty checklist', () => {
      render(<Checklist {...defaultProps} checklist={[]} />);
      
      expect(screen.getByText("Checklist d'Intégration")).toBeInTheDocument();
      expect(screen.getByText('Ajouter un élément')).toBeInTheDocument();
    });

    it('handles mixed format checklist gracefully', () => {
      const mixedChecklist = [
        { étape: 'Objet étape' },
        'String étape'
      ];
      render(<Checklist {...defaultProps} checklist={mixedChecklist} />);
      
      expect(screen.getByText('Objet étape')).toBeInTheDocument();
      expect(screen.getByText('String étape')).toBeInTheDocument();
    });
  });
});
name: Blue/Green Deployment with Zero Cost Strategy

# Prevent concurrent deployments to avoid conflicts
concurrency:
  group: deployment-${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: false

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment for blue-green deployment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - production

env:
  NODE_VERSION: '20'
  AZURE_WEBAPP_PACKAGE_PATH: './api'
  AZURE_STATIC_WEB_APPS_PACKAGE_PATH: './client'

jobs:
  # Check deployment readiness
  check-prerequisite:
    runs-on: ubuntu-latest
    outputs:
      should-run: ${{ steps.check.outputs.result }}
    steps:
      - name: Check deployment readiness
        id: check
        run: |
          echo "result=true" >> $GITHUB_OUTPUT
          echo "âœ… Blue-green deployment triggered - proceeding with deployment"

  # Generate semantic version and setup
  version-and-setup:
    needs: check-prerequisite
    runs-on: ubuntu-latest
    if: needs.check-prerequisite.outputs.should-run == 'true'
    outputs:
      version: ${{ steps.version.outputs.version }}
      version-tag: ${{ steps.version.outputs.version-tag }}
      environment: ${{ steps.env.outputs.environment }}
      resource-group: ${{ steps.env.outputs.resource-group }}
      webapp-name: ${{ steps.env.outputs.webapp-name }}
      static-app-name: ${{ steps.env.outputs.static-app-name }}
      deploy-infrastructure: ${{ steps.env.outputs.deploy-infrastructure }}
      deployment-id: ${{ steps.deployment.outputs.deployment-id }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate version
        id: version
        uses: paulhatch/semantic-version@v5.4.0
        with:
          tag_prefix: "v"
          major_pattern: "BREAKING CHANGE:"
          minor_pattern: "feat:"
          version_format: "${major}.${minor}.${patch}"
          change_path: "."
          namespace: ""
          bump_each_commit: false
          search_commit_body: true

      - name: Determine environment
        id: env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "resource-group=hr-onboarding-prod-rg" >> $GITHUB_OUTPUT
            echo "webapp-name=hr-onboarding-prod-api" >> $GITHUB_OUTPUT
            echo "static-app-name=hr-onboarding-prod-web" >> $GITHUB_OUTPUT
            echo "deploy-infrastructure=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "resource-group=hr-onboarding-staging-rg" >> $GITHUB_OUTPUT
            echo "webapp-name=hr-onboarding-staging-api" >> $GITHUB_OUTPUT
            echo "static-app-name=hr-onboarding-staging-web" >> $GITHUB_OUTPUT
            echo "deploy-infrastructure=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/dev" ]]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "resource-group=hr-onboarding-dev-rg" >> $GITHUB_OUTPUT
            echo "webapp-name=hr-onboarding-dev-r2x0-api" >> $GITHUB_OUTPUT
            echo "static-app-name=hr-onboarding-dev-r2x0-web" >> $GITHUB_OUTPUT
            echo "deploy-infrastructure=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate deployment ID
        id: deployment
        run: |
          # Create unique deployment identifier for blue/green tracking
          DEPLOYMENT_ID="deploy-$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA:0:8}"
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "ğŸ”µ Deployment ID: $DEPLOYMENT_ID"

  # Run tests and quality checks
  test-and-validate:
    needs: [check-prerequisite, version-and-setup]
    runs-on: ubuntu-latest
    if: needs.check-prerequisite.outputs.should-run == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install API dependencies
        run: npm install
        working-directory: ./api

      - name: Install Client dependencies
        run: npm install
        working-directory: ./client

      - name: Run quality checks
        run: |
          echo "ğŸ” Running quality checks for blue deployment"
          # API checks
          cd api
          npm run lint
          npm run format:check
          npm audit --audit-level=moderate
          npm test
          cd ../client
          # Client checks
          npm run lint
          npm run format:check
          npm audit --audit-level=moderate
          npm test
          npm run build

  # Restore Terraform state
  restore-terraform-state:
    needs: [version-and-setup, test-and-validate]
    runs-on: ubuntu-latest
    if: needs.version-and-setup.outputs.deploy-infrastructure == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Restore Terraform state from GitHub
        uses: ./.github/workflows/state-management.yml
        with:
          environment: ${{ needs.version-and-setup.outputs.environment }}
          action: 'restore'
          state_file: 'terraform.tfstate'

  # Deploy infrastructure with state management
  deploy-infrastructure:
    needs: [version-and-setup, test-and-validate, restore-terraform-state]
    runs-on: ubuntu-latest
    if: needs.version-and-setup.outputs.deploy-infrastructure == 'true'
    environment: 
      name: ${{ needs.version-and-setup.outputs.environment }}
      url: https://${{ needs.version-and-setup.outputs.webapp-name }}.azurewebsites.net
    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Terraform Init
        run: |
          echo "ğŸš€ Initializing Terraform"
          # Use local backend for deployment
          terraform init -backend-config="path=.terraform/terraform.tfstate"
        working-directory: ./terraform

      - name: Terraform Plan
        run: |
          terraform plan \
            -var-file="environments/${{ needs.version-and-setup.outputs.environment }}.tfvars" \
            -var="openai_api_key=${{ secrets.OPENAI_API_KEY }}" \
            -out=tfplan
        working-directory: ./terraform

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan
        working-directory: ./terraform

      - name: Setup Application Insights
        run: |
          echo "ğŸ” Setting up Application Insights for ${{ needs.version-and-setup.outputs.environment }}"
          
          # Create Application Insights instance
          az monitor app-insights component create \
            --app hr-onboarding-${{ needs.version-and-setup.outputs.environment }}-insights \
            --location westeurope \
            --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
            --application-type web \
            --retention-time 90 \
            --kind web || true
          
          # Get instrumentation key
          INSTRUMENTATION_KEY=$(az monitor app-insights component show \
            --app hr-onboarding-${{ needs.version-and-setup.outputs.environment }}-insights \
            --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
            --query instrumentationKey -o tsv)
          
          # Configure API app service with Application Insights
          az webapp config appsettings set \
            --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
            --name ${{ needs.version-and-setup.outputs.webapp-name }} \
            --settings APPINSIGHTS_INSTRUMENTATIONKEY="$INSTRUMENTATION_KEY" || true

      - name: Save Terraform state to GitHub
        uses: ./.github/workflows/state-management.yml
        with:
          environment: ${{ needs.version-and-setup.outputs.environment }}
          action: 'save'
          state_file: 'terraform/terraform.tfstate'

  # Blue Deployment - Deploy new version
  deploy-blue:
    needs: [version-and-setup, test-and-validate]
    runs-on: ubuntu-latest
    timeout-minutes: 45
    environment: 
      name: ${{ needs.version-and-setup.outputs.environment }}
      url: https://${{ needs.version-and-setup.outputs.webapp-name }}.azurewebsites.net
    outputs:
      blue-version: ${{ steps.deploy.outputs.blue-version }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies
        run: npm install
        working-directory: ${{ env.AZURE_WEBAPP_PACKAGE_PATH }}

      - name: Create Blue deployment package
        id: deploy
        run: |
          echo "ğŸ”µ Creating Blue deployment package"
          
          # Set blue version identifier
          BLUE_VERSION="blue-${{ needs.version-and-setup.outputs.deployment-id }}"
          echo "blue-version=$BLUE_VERSION" >> $GITHUB_OUTPUT
          
          # Create deployment package with blue identifier
          cd ${{ env.AZURE_WEBAPP_PACKAGE_PATH }}
          
          # Create production .npmrc for Azure deployment
          echo "Creating production .npmrc for optimized Azure deployment..."
          cat > .npmrc << EOF
          # Production deployment optimizations
          production=true
          omit=dev
          audit=false
          fund=false
          progress=false
          registry=https://registry.npmjs.org/
          EOF
          
          echo "âœ… Production .npmrc created"
          
          # Add blue version to package.json for tracking
          jq --arg version "$BLUE_VERSION" '.blueGreenVersion = $version' package.json > package.json.tmp
          mv package.json.tmp package.json
          
          # Create deployment zip
          zip -r ../api-blue-deployment.zip . \
            -x "*.log" \
            -x ".env*" \
            -x "node_modules/.cache/*"
          
          echo "âœ… Blue deployment package created"

      - name: Upload Blue artifacts
        uses: actions/upload-artifact@v4
        with:
          name: hr-onboarding-blue-${{ needs.version-and-setup.outputs.version }}
          path: ./api-blue-deployment.zip
          retention-days: 30

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Check for ongoing deployments and conflicts
        run: |
          echo "ğŸ” Checking for ongoing deployments and resolving conflicts"
          
          # Wait for any ongoing GitHub Actions workflows to complete
          echo "ğŸ”„ Checking for concurrent GitHub Actions workflows..."
          WORKFLOW_RUNS=$(gh run list --workflow="deploy.yml" --status="in_progress" --limit=10 --json=id || echo "[]")
          if [[ "$WORKFLOW_RUNS" != "[]" && "$WORKFLOW_RUNS" != "" ]]; then
            echo "â³ Waiting for concurrent deploy.yml workflows to complete..."
            sleep 30
          fi
          
          # Check Azure deployment status with enhanced conflict handling
          DEPLOYMENT_STATUS=$(az webapp deployment list \
            --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
            --name ${{ needs.version-and-setup.outputs.webapp-name }} \
            --query "[0].status" \
            --output tsv 2>/dev/null || echo "None")
          
          echo "Current deployment status: $DEPLOYMENT_STATUS"
          
          # If there's an ongoing deployment, wait for it to complete
          if [[ "$DEPLOYMENT_STATUS" == "Running" || "$DEPLOYMENT_STATUS" == "Building" ]]; then
            echo "â³ Waiting for ongoing deployment to complete..."
            for i in {1..60}; do
              sleep 15
              DEPLOYMENT_STATUS=$(az webapp deployment list \
                --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
                --name ${{ needs.version-and-setup.outputs.webapp-name }} \
                --query "[0].status" \
                --output tsv 2>/dev/null || echo "None")
              
              echo "Deployment status check $i/60: $DEPLOYMENT_STATUS"
              
              if [[ "$DEPLOYMENT_STATUS" != "Running" && "$DEPLOYMENT_STATUS" != "Building" ]]; then
                echo "âœ… Previous deployment completed"
                break
              fi
              
              if [[ $i -eq 60 ]]; then
                echo "âš ï¸ Timeout waiting for deployment to complete, attempting to proceed"
                # Try to stop any conflicting operations
                az webapp stop \
                  --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
                  --name ${{ needs.version-and-setup.outputs.webapp-name }} || true
                sleep 10
                az webapp start \
                  --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
                  --name ${{ needs.version-and-setup.outputs.webapp-name }} || true
                sleep 10
              fi
            done
          fi

      - name: Configure Azure App Service for Node.js 20
        run: |
          echo "ğŸ”§ Configuring Azure App Service to use Node.js 20.x"
          
          # Step 1: Force Node.js 20 using multiple methods
          echo "ğŸ“‹ Setting runtime stack to Node.js 20-lts..."
          az webapp config set \
            --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
            --name ${{ needs.version-and-setup.outputs.webapp-name }} \
            --linux-fx-version "NODE|20-lts"
          
          # Step 2: Set Node.js version via app settings (backup method)
          echo "âš™ï¸ Setting Node.js version via app settings..."
          az webapp config appsettings set \
            --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
            --name ${{ needs.version-and-setup.outputs.webapp-name }} \
            --settings \
              WEBSITE_NODE_DEFAULT_VERSION="~20" \
              WEBSITE_NODEJS_DEFAULT_VERSION="~20" \
              NODE_VERSION="20" \
              ORYX_NODE_VERSION="20" \
              WEBSITE_ALWAYS_ON="true"
          
          # Step 3: Configure startup file
          echo "ğŸ”§ Setting startup configuration..."
          az webapp config set \
            --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
            --name ${{ needs.version-and-setup.outputs.webapp-name }} \
            --startup-file "npm start"
          
          # Wait for configuration to apply
          sleep 20
          
          echo "âœ… Azure App Service configured for Node.js 20.x on Linux"

      - name: Deploy Blue to Azure App Service
        run: |
          echo "ğŸ”µ Deploying Blue version to App Service"
          
          # Configure blue environment variables with application settings (using GitHub Secrets)
          # Split into smaller chunks to avoid Azure CLI limits
          
          echo "ğŸ”§ Setting core application variables..."
          az webapp config appsettings set \
            --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
            --name ${{ needs.version-and-setup.outputs.webapp-name }} \
            --settings \
              NODE_ENV="production" \
              PORT="8080" \
              DATABASE_SERVER="hr-onboarding-dev-r2x0-sql.database.windows.net" \
              DATABASE_NAME="hr-onboarding" \
              DATABASE_USERNAME="sqladmin" \
              DATABASE_TYPE="mssql"
          
          echo "ğŸ”§ Setting secret variables..."
          az webapp config appsettings set \
            --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
            --name ${{ needs.version-and-setup.outputs.webapp-name }} \
            --settings \
              DATABASE_PASSWORD="${{ secrets.DATABASE_PASSWORD }}" \
              OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" \
              JWT_SECRET="${{ secrets.JWT_SECRET }}" \
              EMAIL_USERNAME="${{ secrets.EMAIL_USERNAME }}" \
              EMAIL_PASSWORD="${{ secrets.EMAIL_PASSWORD }}"
          
          echo "ğŸ”§ Setting deployment tracking variables..."
          az webapp config appsettings set \
            --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
            --name ${{ needs.version-and-setup.outputs.webapp-name }} \
            --settings \
              DEPLOYMENT_ID="${{ needs.version-and-setup.outputs.deployment-id }}" \
              DEPLOYMENT_VERSION="${{ steps.deploy.outputs.blue-version }}" \
              DEPLOYMENT_TIMESTAMP="$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
              ACTIVE_VERSION="blue"
          
          echo "ğŸ”§ Setting email and auth configuration..."
          az webapp config appsettings set \
            --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
            --name ${{ needs.version-and-setup.outputs.webapp-name }} \
            --settings \
              OPENAI_API_ENDPOINT="https://api.openai.com/v1" \
              JWT_EXPIRY="7d" \
              BCRYPT_SALT_ROUNDS="12" \
              EMAIL_HOST="smtp.gmail.com" \
              EMAIL_PORT="587"
          
          echo "ğŸ”§ Setting Azure build configuration..."
          az webapp config appsettings set \
            --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
            --name ${{ needs.version-and-setup.outputs.webapp-name }} \
            --settings \
              NPM_CONFIG_PRODUCTION="true" \
              SCM_DO_BUILD_DURING_DEPLOYMENT="true" \
              ENABLE_ORYX_BUILD="true" \
              ORYX_PLATFORM_NAME="nodejs" \
              ORYX_PLATFORM_VERSION="20"
          
          # Debug: Check what environment variables were actually set
          echo "ğŸ” Verifying critical environment variables were set..."
          az webapp config appsettings list \
            --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
            --name ${{ needs.version-and-setup.outputs.webapp-name }} \
            --query "[?name=='NODE_ENV' || name=='PORT' || name=='DATABASE_SERVER' || name=='DATABASE_PASSWORD' || name=='JWT_SECRET' || name=='OPENAI_API_KEY'].{name:name, value:value}" \
            --output table
          
          # Restart app to ensure environment variables take effect
          echo "ğŸ”„ Restarting app to apply configuration changes"
          az webapp restart \
            --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
            --name ${{ needs.version-and-setup.outputs.webapp-name }}
          
          # Wait for restart to complete
          sleep 30
          
          # Check application logs for startup issues (with timeout)
          echo "ğŸ“‹ Checking application startup logs for 60 seconds..."
          timeout 60s az webapp log tail \
            --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
            --name ${{ needs.version-and-setup.outputs.webapp-name }} || echo "âœ… Log check completed (timeout after 60s)"
          
          # Deploy blue package with retry logic and extended timeout
          for attempt in {1..5}; do
            echo "ğŸ”„ Deployment attempt $attempt/5"
            
            # Clear any existing deployment locks
            echo "ğŸ”§ Clearing deployment locks..."
            az webapp deployment list-publishing-credentials \
              --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
              --name ${{ needs.version-and-setup.outputs.webapp-name }} > /dev/null 2>&1 || true
            
            # Wait before deployment attempt
            if [[ $attempt -gt 1 ]]; then
              echo "â³ Waiting 90 seconds before retry..."
              sleep 90
            fi
            
            if timeout 600 az webapp deploy \
              --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
              --name ${{ needs.version-and-setup.outputs.webapp-name }} \
              --src-path ./api-blue-deployment.zip \
              --type zip \
              --timeout 600; then
              echo "âœ… Blue deployment completed successfully"
              break
            else
              echo "âŒ Deployment attempt $attempt failed"
              
              # Check deployment status
              echo "ğŸ” Checking deployment status..."
              az webapp deployment list \
                --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
                --name ${{ needs.version-and-setup.outputs.webapp-name }} \
                --query "[0].{status:status, message:message}" \
                --output table || true
              
              if [[ $attempt -eq 5 ]]; then
                echo "ğŸš¨ All deployment attempts failed"
                exit 1
              fi
            fi
          done
          
          # Quick health check after deployment
          echo "ğŸ” Testing application endpoints..."
          API_URL="https://${{ needs.version-and-setup.outputs.webapp-name }}.azurewebsites.net"
          
          # Test simple status endpoint (no database dependency)
          echo "Testing /status endpoint..."
          curl -f -s --max-time 30 "${API_URL}/status" || echo "âŒ /status endpoint failed"
          
          # Test health endpoint (with database)
          echo "Testing /health endpoint..."
          curl -f -s --max-time 30 "${API_URL}/health" || echo "âŒ /health endpoint failed"

      - name: Wait for Blue startup
        run: |
          echo "â³ Waiting for Blue environment to start up"
          sleep 60
          echo "âœ… Blue startup wait completed"

  # Blue Health Check - Validate new version
  validate-blue:
    needs: [version-and-setup, deploy-blue]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      health-status: ${{ steps.health.outputs.status }}
      should-proceed: ${{ steps.health.outputs.proceed }}
    steps:
      - uses: actions/checkout@v4

      - name: Comprehensive Blue Health Check
        id: health
        run: |
          echo "ğŸ” Running optimized health checks on Blue environment"
          
          # Set environment variables
          export ENVIRONMENT="${{ needs.version-and-setup.outputs.environment }}"
          export VERSION="${{ needs.deploy-blue.outputs.blue-version }}"
          export API_URL="https://${{ needs.version-and-setup.outputs.webapp-name }}.azurewebsites.net"
          export FRONTEND_URL="https://${{ needs.version-and-setup.outputs.static-app-name }}.azurewebsites.net"
          
          # Optimized health check with smart retry logic
          echo "ğŸ” Testing API health with optimized timeouts..."
          HEALTH_PASSED=false
          
          # Smart retry: 20 attempts over 10 minutes max
          for i in {1..20}; do
            echo "Health check attempt $i/20..."
            
            # Test /health endpoint with 30s timeout
            if curl -f -s --max-time 30 "${API_URL}/health" >/dev/null 2>&1; then
              echo "âœ… /health endpoint responding"
              
              # Test /status endpoint
              if curl -f -s --max-time 30 "${API_URL}/status" >/dev/null 2>&1; then
                echo "âœ… /status endpoint responding"
                HEALTH_PASSED=true
                break
              else
                echo "âš ï¸ /status endpoint not responding"
              fi
            else
              echo "âš ï¸ /health endpoint not responding"
            fi
            
            # Exponential backoff: start with 15s, increase by 15s each time
            WAIT_TIME=$((15 * i))
            if [[ $WAIT_TIME -gt 60 ]]; then
              WAIT_TIME=60
            fi
            
            echo "â³ Waiting ${WAIT_TIME}s before retry..."
            sleep $WAIT_TIME
          done
          
          if [[ "$HEALTH_PASSED" == "true" ]]; then
            echo "âœ… Blue environment health check PASSED"
            echo "status=healthy" >> $GITHUB_OUTPUT
            echo "proceed=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Blue environment health check FAILED after 10 minutes"
            echo "status=unhealthy" >> $GITHUB_OUTPUT
            echo "proceed=false" >> $GITHUB_OUTPUT
            
            # Try to get detailed error info
            echo "ğŸ” Attempting to get detailed error information..."
            curl -v "${API_URL}/health" || true
            curl -v "${API_URL}/status" || true
            
            exit 1
          fi

      - name: Upload health check results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: blue-health-check-${{ needs.version-and-setup.outputs.environment }}
          path: |
            deployment/health-checks/health-check.log
            deployment/health-checks/health-report.json
          retention-days: 7

  # Frontend Blue Deployment
  deploy-frontend-blue:
    needs: [version-and-setup, validate-blue]
    runs-on: ubuntu-latest
    timeout-minutes: 20
    if: needs.validate-blue.outputs.should-proceed == 'true'
    environment: 
      name: ${{ needs.version-and-setup.outputs.environment }}
      url: https://${{ needs.version-and-setup.outputs.static-app-name }}.azurewebsites.net
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies
        run: npm install
        working-directory: ${{ env.AZURE_STATIC_WEB_APPS_PACKAGE_PATH }}

      - name: Build Blue frontend
        run: |
          echo "ğŸ”µ Building Blue frontend application"
          npm run build
        working-directory: ${{ env.AZURE_STATIC_WEB_APPS_PACKAGE_PATH }}
        env:
          VITE_API_URL: https://${{ needs.version-and-setup.outputs.webapp-name }}.azurewebsites.net
          VITE_VERSION: ${{ needs.deploy-blue.outputs.blue-version }}

      - name: Upload Client Blue artifacts
        uses: actions/upload-artifact@v4
        with:
          name: hr-onboarding-client-blue-${{ needs.version-and-setup.outputs.version }}
          path: ${{ env.AZURE_STATIC_WEB_APPS_PACKAGE_PATH }}/dist/
          retention-days: 30

      - name: Deploy Blue frontend
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          action: 'upload'
          app_location: '/client'
          api_location: ''
          output_location: 'dist'

  # Final Health Check - Validate complete Blue environment
  final-health-check:
    needs: [version-and-setup, deploy-blue, validate-blue, deploy-frontend-blue]
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: needs.validate-blue.outputs.should-proceed == 'true'
    outputs:
      deployment-successful: ${{ steps.final.outputs.success }}
    steps:
      - uses: actions/checkout@v4

      - name: Final comprehensive health check
        id: final
        run: |
          echo "ğŸ” Running final optimized health check on complete Blue environment"
          
          # Brief wait for frontend deployment to stabilize
          sleep 15
          
          export ENVIRONMENT="${{ needs.version-and-setup.outputs.environment }}"
          export VERSION="${{ needs.deploy-blue.outputs.blue-version }}"
          export API_URL="https://${{ needs.version-and-setup.outputs.webapp-name }}.azurewebsites.net"
          export FRONTEND_URL="https://${{ needs.version-and-setup.outputs.static-app-name }}.azurewebsites.net"
          
          # Quick final validation with 5 minute timeout max
          echo "ğŸ” Final validation with quick checks..."
          FINAL_PASSED=false
          
          # Quick retry: 10 attempts over 5 minutes max
          for i in {1..10}; do
            echo "Final check attempt $i/10..."
            
            # Test both key endpoints quickly
            if curl -f -s --max-time 20 "${API_URL}/health" >/dev/null 2>&1 && \
               curl -f -s --max-time 20 "${API_URL}/status" >/dev/null 2>&1; then
              echo "âœ… API endpoints responding correctly"
              FINAL_PASSED=true
              break
            else
              echo "âš ï¸ API endpoints not responding, retrying..."
            fi
            
            # Fixed 30s interval for final checks
            sleep 30
          done
          
          if [[ "$FINAL_PASSED" == "true" ]]; then
            echo "âœ… Final Blue environment validation PASSED"
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Final Blue environment validation FAILED after 5 minutes"
            echo "success=false" >> $GITHUB_OUTPUT
            
            # Get detailed error info
            echo "ğŸ” Final error diagnostics..."
            curl -v "${API_URL}/health" || true
            curl -v "${API_URL}/status" || true
            
            exit 1
          fi

  # Traffic Switch - Make Blue the active version (Green becomes standby)
  switch-to-blue:
    needs: [version-and-setup, final-health-check]
    runs-on: ubuntu-latest
    if: needs.final-health-check.outputs.deployment-successful == 'true'
    environment: 
      name: ${{ needs.version-and-setup.outputs.environment }}
      url: https://${{ needs.version-and-setup.outputs.webapp-name }}.azurewebsites.net
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Switch traffic to Blue (Zero-downtime)
        run: |
          echo "ğŸ”„ Switching traffic to Blue environment"
          
          # Update application settings to mark Blue as active
          az webapp config appsettings set \
            --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
            --name ${{ needs.version-and-setup.outputs.webapp-name }} \
            --settings \
              ACTIVE_VERSION="blue" \
              PREVIOUS_VERSION="green" \
              LAST_DEPLOYMENT_ID="${{ needs.version-and-setup.outputs.deployment-id }}" \
              SWITCH_TIMESTAMP="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          
          echo "âœ… Traffic switched to Blue environment"
          echo "ğŸŸ¢ Green environment kept as standby for rollback"

      - name: Post-switch validation
        run: |
          echo "ğŸ” Validating traffic switch"
          
          # Brief wait for configuration to propagate
          sleep 15
          
          # Quick health check to confirm switch was successful
          API_URL="https://${{ needs.version-and-setup.outputs.webapp-name }}.azurewebsites.net"
          
          if curl -f -s --max-time 30 "${API_URL}/health" > /dev/null; then
            echo "âœ… Post-switch health check passed"
            echo "ğŸš€ Blue/Green deployment completed successfully"
          else
            echo "âŒ Post-switch health check failed"
            echo "ğŸš¨ Immediate rollback may be required"
            exit 1
          fi

  # Rollback job (only runs on failure)
  emergency-rollback:
    needs: [version-and-setup, validate-blue, final-health-check]
    runs-on: ubuntu-latest
    if: failure() && (needs.validate-blue.outputs.should-proceed == 'false' || needs.final-health-check.outputs.deployment-successful == 'false')
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Emergency rollback to Green
        run: |
          echo "ğŸš¨ EMERGENCY ROLLBACK: Blue deployment failed"
          
          # Switch back to Green (previous version)
          az webapp config appsettings set \
            --resource-group ${{ needs.version-and-setup.outputs.resource-group }} \
            --name ${{ needs.version-and-setup.outputs.webapp-name }} \
            --settings \
              ACTIVE_VERSION="green" \
              ROLLBACK_REASON="Blue deployment health check failed" \
              ROLLBACK_TIMESTAMP="$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
              FAILED_DEPLOYMENT_ID="${{ needs.version-and-setup.outputs.deployment-id }}"
          
          echo "âœ… Emergency rollback completed"
          echo "ğŸŸ¢ Service restored to Green environment"

      - name: Send rollback notification
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 587
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          subject: "ğŸš¨ EMERGENCY ROLLBACK - HR Onboarding ${{ needs.version-and-setup.outputs.environment }}"
          to: andrelaurelyvan.kanmegnetabouguie@ynov.com
          from: ${{ secrets.EMAIL_USERNAME }}
          html_body: |
            <h2>ğŸš¨ Emergency Rollback Executed</h2>
            
            <p><strong>Environment:</strong> ${{ needs.version-and-setup.outputs.environment }}</p>
            <p><strong>Failed Deployment ID:</strong> ${{ needs.version-and-setup.outputs.deployment-id }}</p>
            <p><strong>Rollback Time:</strong> $(date -u)</p>
            <p><strong>Reason:</strong> Blue deployment health checks failed</p>
            
            <h3>ğŸ”— Investigation Links</h3>
            <ul>
              <li><a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">View Failed Deployment</a></li>
              <li><a href="https://${{ needs.version-and-setup.outputs.webapp-name }}.azurewebsites.net/health">Check API Health</a></li>
            </ul>
            
            <p><strong>Status:</strong> Service restored to previous working version</p>

  # Create GitHub Release (only for production)
  create-release:
    needs: [version-and-setup, switch-to-blue]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && needs.switch-to-blue.result == 'success'
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            CHANGELOG=$(git log --pretty=format:"- %s" --no-merges)
          else
            CHANGELOG=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s" --no-merges)
          fi
          
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.version-and-setup.outputs.version-tag }}
          release_name: Release ${{ needs.version-and-setup.outputs.version }}
          body: |
            ## ğŸš€ Release ${{ needs.version-and-setup.outputs.version }}
            
            ### ğŸ“‹ Changes
            ${{ steps.changelog.outputs.changelog }}
            
            ### ğŸ”µ Blue/Green Deployment
            - **Deployment ID:** ${{ needs.version-and-setup.outputs.deployment-id }}
            - **Blue Version:** ${{ needs.deploy-blue.outputs.blue-version }}
            - **Zero-Downtime:** âœ… Achieved
            - **Health Checks:** âœ… All passed
            
            ### ğŸ”— Deployment URLs
            - **API:** https://${{ needs.version-and-setup.outputs.webapp-name }}.azurewebsites.net
            - **Frontend:** https://${{ needs.version-and-setup.outputs.static-app-name }}.azurewebsites.net
            - **API Docs:** https://${{ needs.version-and-setup.outputs.webapp-name }}.azurewebsites.net/api-docs
            
            ### ğŸ“¦ Artifacts
            - API Package: `hr-onboarding-blue-${{ needs.version-and-setup.outputs.version }}`
            - Client Build: `hr-onboarding-client-blue-${{ needs.version-and-setup.outputs.version }}`
            
            ---
            ğŸ¤– Generated with [Claude Code](https://claude.ai/code)
          draft: false
          prerelease: false